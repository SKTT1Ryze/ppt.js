<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>ccc's graduation project</title>

    <style>
      .tiedContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
      }

      .tiedItem {
        display: flex;
        flex: 1 1 150px;
        margin: 5px 64px;
        height: 50px;
        justify-content: left;
      }

      .imageText {
        display: flex;
        gap: 16px;
        /* align-items: center; */
        justify-content: space-between;

        .imageTextItem {
          display: flex;
          flex: 1;
          flex-wrap: wrap;
          align-content: center;
        }

        .image {
          display: flex;
          flex: 1;
        }
      }

      .codeText {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
      }

      .codeTextItem {
        flex: 1 1 150px;
        margin-right: 50px;
        margin-top: 0px;
      }

      .archDesignContainer {
        display: flex;
        flex-direction: column;
        gap: 30px;

        .io_uring {
          display: flex;
          height: 50px;
          width: 200px;
          border: solid yellow;
          border-radius: 0.2rem;
          background: #ffff0069;
          margin: auto;
          justify-content: center;
          align-items: center;
        }

        .scheduler {
          display: flex;
          height: 50px;
          width: 500px;
          border: solid blue;
          border-radius: 0.2rem;
          background: #00ceff73;
          margin: auto;
          padding-right: 30px;
          justify-content: right;
          align-items: center;
        }

        .executor {
          display: flex;
          height: 50px;
          width: 200px;
          border: solid red;
          border-radius: 0.2rem;
          background: #ff000045;
          margin: auto;
          justify-content: center;
          align-items: center;
        }

        .task {
          display: flex;
          position: fixed;
          height: 30px;
          width: 30px;
          border: solid green;
          border-radius: 0.2rem;
          background: #00800054;
          justify-content: center;
          align-items: center;
          font-size: small;
        }

        .label {
          position: fixed;
        }
      }
    </style>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/custom.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />

    <link rel="icon" href="images/sktt1ryze.jpg" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <img
          src="images/hust.png"
          alt="hust_logo"
          width="80"
          height="80"
          style="float: left"
        />

        <a href="https://github.com/SKTT1Ryze/ppt.js">
          <img
            src="images/github.svg"
            alt="github"
            width="50"
            height="50"
            style="float: right"
          />
        </a>

        <section
          data-background-image="images/background2.jpeg"
          data-background-opacity="0.25"
        >
          <h2>High Performance Asynchronous Programming Framework</h2>
          <h4>based on Linux Asynchronous I/O and Coroutine</h4>
          <!-- <h3 class="tiedContainer"> -->
          <!--   <div class="tiedItem">答辩学生：车春池</div> -->
          <!-- </h3> -->
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <!-- <h2>Contents</h2> -->
          <h3 class="tiedContainer">
            <div class="tiedItem">
              <a href="/#/2">
                01 Introduction
              </a>
            </div>
            <div class="tiedItem">
              <a href="/#/8">
                02 Literature Review
              </a>
            </div>
          </h3>
          <h3 class="tiedContainer">
            <div class="tiedItem">
              <a href="/#/9">
                03 Methodology
              </a>
            </div>
            <div class="tiedItem">
              <a href="/#/24">
                04 Results
              </a>
            </div>
          </h3>
        </section>
        <!-- 下面我将会从以下四个方面介绍我的毕设项目。 -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Background of the Study</h3>
          <div style="text-align: left">
            <h4>The Input/Output(I/O) operations in the traditional high-concurrency system:</h4>
            <ol>
              <li>use Synchronous I/O</li>
              <ul>
                <li>Applications processing cannot continue until the I/O operation is completed.</li>
              </ul>
              <li>use Multithreading</li>
              <ul>
                <li>The cost of thread switching is very high.</li>
              </ul>
            </ol>
            <h4 style="margin-top: 16px;color: red">Both of them lead to weak system throughput performance in high-concurrency scenarios.</h4>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Modern Solutions</h3>
          <div style="text-align: left">
            <h4>Maybe we can improve this situation with two steps:</h4>
            <ol>
              <li>replace Synchronous I/O with the Asynchronous I/O.</li>
              <li>utilize the Coroutine technology.</li>
            </ol>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Asynchronous I/O vs Synchronous I/O</h3>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  Synchronous I/O operations block the thread until the I/O request has completed.
                </li>
                <li style="margin-bottom: 5px">
                  Asynchronous I/O operations run in the background and do not block any thread.
                </li>
              </ol>
              <h4 style="text-align:left;margin-top: 16px;color: #00b9ff">
                Asynchronous I/O improves performance, because I/O operations and application processing can run simultaneously.
              </h4>
            </div>
            <div class="image">
              <img
                src="images/sync_io_vs_async_io.png"
                alt="sync-vs-async"
                width="600"
                style="float: right"
              />
            </div>
          </div>
        </section>
        <!-- In synchronous I/O, a thread starts an I/O operation and immediately enters a wait state until the I/O request has completed. -->
        <!-- A thread performing asynchronous I/O sends an I/O request to the kernel by calling an appropriate function. -->
        <!-- If the request is accepted by the kernel, the calling thread continues processing another job until the kernel signals to the thread that the I/O operation is complete. -->
        <!-- It then interrupts its current job and processes the data from the I/O operation as necessary. -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>io_uring: Asynchronous I/O API for Linux</h3>
          <h4 style="text-align: left">io_uring is a new asynchronous I/O API for Linux with very low performance overheads.</h4>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  Shared memory and circular queues for information exchange between kernel and user.
                </li>
                <!-- it uses shared memory and circular queues to facilitate information exchange between kernel space and user space. -->
                <li style="margin-bottom: 5px">Submission Queue(SQ) for submitting I/O requests.</li>
                <li style="margin-bottom: 5px">
                  Completion Queue(CQ) for obtaining I/O completion events.
                </li>
                <!-- <li style="margin-bottom: 5px"> -->
                <!--   it supports lock-free concurrency, and achieves state synchronization internally through memory barrier techniques. -->
                <!-- </li> -->
              </ol>
            </div>
            <div class="image">
              <img
                src="images/io_uring.png"
                alt="io_uring"
                width="600"
                style="float: right"
              />
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Coroutine: suspendable and resumable Function</h3>
          <h4 style="text-align: left">Coroutines are functions that allow execution to be suspended and resumed.</h4>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  A coroutine is a function that can suspend execution to be resumed later.
                </li>
                <li style="margin-bottom: 5px">
                  It allows handle non-blocking I/O without explicit callbacks.
                </li>
                <li style="margin-bottom: 5px">Advantages over threads: Lower context-switching overhead.</li>
                <li style="margin-bottom: 5px">
                  Disadvantages over threads: Inability to utilize multi-core CPU, cannot execute concurrently.
                </li>
              </ol>
            </div>
            <div class="image">
              <img
                src="images/coroutines.png"
                alt="coroutine"
                width="550"
                style="float: right"
              />
            </div>
          </div>
          <h5 style="text-align: right">
            <a href="https://blog.eiler.eu/posts/20210512/">reference</a>
          </h5>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Research Objectives</h3>
          <h4 style="text-align: left">
            The goal is to design and implement a high-performance programming framework similar to OpenMPI but with distinct features based on Linux io_uring and Coroutines.
          </h4>
          <div class="imageText">
            <div class="imageTextItem">
              <h4>Commonalities with OpenMPI:</h4>
              <ol>
                <li style="margin-bottom: 5px">Aim to enhance system performance.</li>
                <li style="margin-bottom: 5px">
                  Applicable to system where multiple tasks are executed concurrently.
                </li>
              </ol>
            </div>
            <div class="imageTextItem">
              <h4>Differences from OpenMPI:</h4>
              <ol>
                <li style="margin-bottom: 5px">
                  It's designed for I/O-intensive tasks while OpenMPI is designed for compute-intensive tasks.
                </li>
                <li style="margin-bottom: 5px">
                  It's based on asynchronous coroutines while OpenMPI is based on inter-process communication.
                </li>
                <li style="margin-bottom: 5px">
                  It typically manages concurrency within a single computer while OpenMPI is primarily used across multiple computers or compute nodes.
                </li>
              </ol>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h3>Literature Review</h3>
          <h4 style="text-align: left">
            There are some relevant literature:
          </h4>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  <a href="https://dl.acm.org/doi/abs/10.1145/3534056.3534945">
                    Understanding modern storage APIs: a systematic study of libaio, SPDK, and io_uring
                  </a>
                </li>
                <li style="margin-bottom: 5px">
                  <a href="https://cir.nii.ac.jp/crid/1050011097152555264">
                    Comparative Evaluation of Asynchronous IO Interface between io_uring and libaio implemented in a NoSQL DB for SSDs
                  </a>
                </li>
                <li style="margin-bottom: 5px">
                  <a href="http://131.159.16.103/~fent/papers/coroutines.pdf">
                    Use Coroutines for Asynchronous I/O to Hide I/O Latencies and Maximize the Read Bandwidth
                  </a>
                </li>
                <li style="margin-bottom: 5px">
                  <a href="https://ieeexplore.ieee.org/abstract/document/10177439">
                    Evaluating Asynchronous Parallel I/O on HPC Systems
                  </a>
                </li>
              </ol>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div>
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:150px">
                Task
              </div>
              <div class="label" style="bottom:90px;left:20px;">Create task</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div>
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:150px">
                Task
              </div>
              <div class="label" style="bottom:180px;left:160px;">Submit I/O Request</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div>
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:250px">
                Task
              </div>
              <div class="label" style="bottom:90px;left:150px;">Push</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div>
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:250px">
                Task
              </div>
              <div class="label" style="bottom:180px;left:600px;">Complete</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:800px">
                Task
              </div>
              <div class="label" style="bottom:90px;left:750px;">Pop</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:10px;left:540px">
                Task
              </div>
              <div class="label" style="bottom:10px;left:600px;">Execute</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:-80px;left:460px">
                Task
              </div>
              <div class="label" style="bottom:-80px;left:520px;">Finish</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:10px;left:540px">
                Task
              </div>
              <div class="label" style="bottom:10px;left:600px;">If reach next I/O...</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:10px;left:150px">
                Task
              </div>
              <div class="label" style="bottom:10px;left:200px;">Suspend the task</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
          data-auto-animate
        >
          <div style="height:100%">
            <h3 style="position:relative;bottom:100px">Architectural Design</h3>
            <div class="archDesignContainer">
              <div data-id="io_uring" class="io_uring">IoUring</div>
              <div data-id="scheduler" class="scheduler">Waiting Queue</div>
              <div data-id="executor" class="executor">Executor</div>
              <div data-id="task0" class="task" style="bottom:90px;left:150px">
                Task
              </div>
              <div class="label" style="bottom:90px;left:20px;">Repeat</div>
              <div data-id="task1" class="task" style="bottom:90px;left:300px"></div>
              <div data-id="task2" class="task" style="bottom:90px;left:350px"></div>
              <div data-id="task3" class="task" style="bottom:90px;left:400px"></div>
              <div data-id="task4" class="task" style="bottom:90px;left:450px"><div>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <div><h4>多核架构设计</h4></div>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  参考<a
                    href="https://helda.helsinki.fi//bitstream/handle/10138/313642/tpc_ancs19.pdf?sequence=1"
                    >Thread-Per-Core</a
                  >架构设计；
                </li>
                <li style="margin-bottom: 5px">
                  为每个核创建一个io_uring实例；
                </li>
                <li style="margin-bottom: 5px">
                  在同一个io_uring实例注册的Task只能在同一个核上运行；
                </li>
                <li style="margin-bottom: 5px">
                  设计目的是减少核间数据同步和线程切换。
                </li>
              </ol>
            </div>
            <div class="image">
              <img
                src="images/multicore-design.drawio.svg"
                alt="multicore-design"
                width="520"
                height="400"
                style="float: right"
              />
            </div>
          </div>
        </section>
        <!-- 框架的多核架构设计参考了Thread-Per-Core模型，
        为每个核配置一个io_uring实例，
        在一个io_uring实例上注册的Task只能在同一个核上运行，
        这样设计的目的是减少CPU核之间的数据同步和线程切换，
        进而降低系统整体延迟。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <div><h4>Task模块设计</h4></div>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  基于<mark>面向对象</mark>的思想，将所有I/O操作统一抽象成Op类；
                </li>
                <li style="margin-bottom: 5px">
                  继承Op父类可派生出Op子类，每个Op子对象对应一个I/O操作；
                </li>
                <li style="margin-bottom: 5px">
                  一个Task由一个或多个Op子对象呈树状构成。
                </li>
              </ol>
            </div>
            <div class="image">
              <img
                src="images/op-task.drawio.svg"
                alt="op-task"
                width="800"
                height="400"
                style="float: right"
              />
            </div>
          </div>
        </section>
        <!-- 下面主要重点介绍一下Task模块的设计与实现。
        首先介绍一下Op类的概念。Linux平台上存在很多种I/O操作，
        比如打开文件，文件读，文件写，建立Tcp连接等等，
        这些I/O操作在io_uring的语境下的区别仅仅在于提交
        的I/O请求不同，因此为了提高代码复用度，降低工作量，
        这里基于面向对象的思想，将所有I/O请求抽象为Op类。xxx-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <div><h4>Task模块设计</h4></div>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">一个Task对应一个协程；</li>
                <li style="margin-bottom: 5px">
                  Task在执行过程中可以挂起和恢复；
                </li>
                <li style="margin-bottom: 5px">
                  Task中的每个Op子对象对应为一个切换点；
                </li>
                <li style="margin-bottom: 5px">
                  Task执行到切换点有两种状态：就绪和等待；
                </li>
                <ul>
                  <li style="margin-bottom: 5px">就绪状态下继续执行；</li>
                  <li style="margin-bottom: 5px">等待状态下挂起。</li>
                </ul>
                <li style="margin-bottom: 5px">
                  Task恢复时从上次挂起的地方继续执行。
                </li>
              </ol>
            </div>
            <div class="image">
              <img
                src="images/task-execute.drawio.svg"
                alt="task-execute"
                width="500"
                height="400"
                style="float: right"
              />
            </div>
          </div>
        </section>
        <!-- Task对应协程的概念，它可以在执行过程中挂起和恢复，
        Task由一个或多个Op子对象组成，每个Op子对象都是一个切换点，
        Task运行到切换点时会检查此处的I/O状态，如果是就绪状态，
        则继续运行，如果是等待状态，当前Task则需要被挂起，等待I/O操作完成。
        恢复执行后，Task从上次挂起的地方继续执行。
        右边是Task模块在执行时的时序图。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>Task模块实现（Rust）</h4>
          <div class="codeText">
            <div class="codeTextItem" style="vertical-align: middle">
              <ol>
                <li style="margin-bottom: 5px">
                  Rust不支持面向对象编程，参考前端框架<a
                    href="https://reactjs.org/"
                    >React</a
                  >的设计， 使用<mark>组件化</mark>的方式达到继承的效果；
                </li>
                <li style="margin-bottom: 5px">
                  子组件接口SubOp：创建I/O请求方法create_sqe；
                </li>
                <li style="margin-bottom: 5px">
                  Future是Rust官方提供用于异步编程的接口；
                </li>
                <li style="margin-bottom: 5px">
                  为Op&ltT&gt实现Future接口：第一次执行调用子组件的create_sqe方法创建sqe，
                  然后注册到IoUring模块，接着挂起；恢复后（第二次调用）返回结果。
                </li>
              </ol>
            </div>
            <div class="codeTextItem">
              <pre><code data-line-numbers data-trim data-noescape><script type="text/template">
                /// 子组件需要实现的接口
                trait SubOp {
                  fn create_sqe(&self) -> Sqe;
                }
                /// Op结构体作为父组件
                struct Op<T: SubOp> {
                  component: T,
                  is_completed: bool
                  ...
                }
                // 为父组件实现Future接口
                impl<T: SubOp> Future for Op<T> {
                  type Output = ...;
                  fn poll(&self, ...) -> Poll<Self::Output> {
                    if !self.is_completed {
                      // 第一次调用

                      // 通过子组件创建I/O请求sqe
                      let sqe = self.component.create_sqe();

                      // 注册sqe到IoUring模块
                      io_uring.submit(sqe);

                      // 挂起
                      return Poll::Pending;
                    } else {
                      // I/O事件已经完成
                      return Poll::Ready(...);
                    }
                  }
                }
              </script></code></pre>
            </div>
          </div>
        </section>
        <!-- 这里介绍一下Rust语言中Task模块的实现。
        Rust不支持面向对象编程，因此这里参考前端框架React的设计，
        采用组件化的方式达到继承的效果。
        先定义一个名为SubOp的接口，这个接口有一个create_sqe方法，
        用于创建I/O请求。然后定义一个Op结构体，
        这个Op以实现了SubOp接口的结构体作为子组件。
        接着为Op实现Future接口，Future是Rust语言官方提供的用于
        异步编程的接口，接口中只有一个poll方法。
        实现Future接口的具体逻辑是
        第一次执行poll方法时调用子组件的create_sqe方法创建
        I/O请求，然后将这个请求注册到IoUring模块，
        接着挂起当前Task；Task被恢复后，再次执行poll方法，
        这时候直接返回I/O操作的结果。
        右边是示例代码。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>Task模块实现（Rust）</h4>
          <div class="codeText">
            <div class="codeTextItem" style="vertical-align: middle">
              <ol>
                <li style="margin-bottom: 5px">
                  Future对象具有<mark>组合性</mark>；
                </li>
                <li style="margin-bottom: 5px">
                  一个Op&ltT&gt对应一个叶子Future， 一个Task对应一个大Future，
                </li>
                <li style="margin-bottom: 5px">
                  通过Future的组合性将一个或多个Op&ltT&gt组合成一个Task；
                </li>
                <li style="margin-bottom: 5px">
                  <mark>async/await</mark
                  >：Rust编译器在语言层面为Future组合性提供的支持。
                </li>
              </ol>
            </div>
            <div class="codeTextItem">
              <pre><code data-line-numbers data-trim data-noescape><script type="text/template">
                // Rust编译器将async函数的返回值
                // 转换成Future
                async fn task() {
                  ...

                  op1.await;
                  op2.await;
                  
                  ...
                }
              </script></code></pre>
            </div>
            <div class="codeTextItem">
              <img
                src="images/future-combine.drawio.svg"
                alt="future-combine"
              />
            </div>
          </div>
        </section>
        <!-- 在Rust中，Future具有组合性，多个子Future可以组合成一个大Future。
        于是一个Op对应于一个子Future，一个Task对应于一个大Future，
        通过Future的组合性可以将一个或多个Op组合成一个Task。
        此外，Rust编译器为这种组合性提供了支持，它将async关键字标记的
        函数或函数块的返回值转换成大Future，使得我们可以像写同步代码
        一样编写异步代码。
        -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>Rust实现中Task执行流程</h4>
          <div class="codeText">
            <div class="codeTextItem">
              <img
                src="images/task-rust.drawio.svg"
                alt="task-rust"
                width="650"
              />
            </div>
          </div>
        </section>
        <!-- 最终Rust实现中Task执行的时序图如下。 -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>Task模块实现（C++）</h4>
          <div class="codeText">
            <div class="codeTextItem" style="vertical-align: middle">
              <ol>
                <li style="margin-bottom: 5px">
                  C++20官方提供Promise和Awaitable两个接口用于协程编程；
                </li>
                <ul>
                  <li>Promise：作为协程的函数返回类型必须实现Promise接口；</li>
                  <li>Awaitable：类似于Rust中的Future接口，表示一个将来值。</li>
                </ul>
                <li style="margin-bottom: 5px">Task实现过程：</li>
                <ul>
                  <li>定义Task类，并为其实现Promise接口；</li>
                  <li>
                    定义Op&ltT&gt类，并为其实现Awaitable接口，实现思路和在Rust中实现Future接口类似；
                  </li>
                  <li>通过重写create_sqe方法派生Op子类。</li>
                </ul>
              </ol>
            </div>
            <div class="codeTextItem">
              <pre><code data-line-numbers data-trim data-noescape><script type="text/template">
                // 示例代码，无法编译
                template <typename T>
                class Task {
                  public:
                    struct promise_type;
                    using handle_type = std::coroutine_handle<promise_type>;
                    
                    // 实现Promise接口
                    struct promise_type {
                      T value;

                      Task get_return_object();
                      std::suspend_never initial_suspend() { return {}; }
                      std::suspend_never final_suspend() noexcept { return {}; }
                      std::suspend_never return_value(T v) {
                        value = v;
                        return {};
                      }
                    }
                    
                    handle_type h_;

                    T result() { return h_.promise().value; }
                };

                template <typename T>
                class Op {
                  public:
                    std::shared_ptr<io_uring> uring;
                    
                    // Op子类需要重写该函数
                    struct io_uring_sqe create_sqe();
                    
                    // 实现Awaitable接口
                    bool await_ready() { return false; }
                    void await_suspend(std::coroutine_handle<> h) {
                      // 通过create_sqe方法创建I/O请求sqe
                      auto sqe = this->create_sqe();

                      // 将sqe注册到IoUring模块中
                      this->uring.submit(sqe);

                      // 挂起
                      return;
                    }
                    auto await_resume() {
                      // 恢复
                      
                      // 从IoUring模块收割结果
                      auto res = this->uring.completion().result();
                      
                      return res;
                    }

                  private:
                    T value;
                };
              </script></code></pre>
            </div>
          </div>
        </section>
        <!-- 然后介绍下C++语言中Task模块的实现。
        C++20官方提供了Promise和Awaitable两个接口用于异步编程。
        在C++中返回类型实现了Promise接口的函数被视为协程，而Awaitable接口类似于
        Rust中的Future接口，表示一个将来值。
        因此，C++中Task的实现过程为：
        先定义一个Task类，并为其实现Promise接口，
        然后定义Op类，并为其实现Awaitable接口，实现思路和Rust中为Op实现Future接口类似。
        最后通过重写Op父类中的create_sqe方法来派生Op子类。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>Task模块实现（C++）</h4>
          <div class="codeText">
            <div class="codeTextItem" style="vertical-align: middle">
              <ol>
                <li style="margin-bottom: 5px">
                  Awaitable对象具有<mark>传递性</mark>；
                </li>
                <li style="margin-bottom: 5px">
                  一个Op&ltT&gt对应一个Awaitable对象，
                  多个Op&ltT&gt可以在一个Task内部传递；
                </li>
                <li style="margin-bottom: 5px">
                  通过Awaitable的传递性将一个或多个Op&ltT&gt组合成一个Task；
                </li>
                <li style="margin-bottom: 5px">
                  <mark>co_await/co_return</mark
                  >：C++20编译器在语言层面为Awaitable传递性提供的支持。
                </li>
              </ol>
            </div>
            <div class="codeTextItem">
              <pre><code data-line-numbers data-trim data-noescape><script type="text/template">
                Task<int> task() {
                  ...

                  co_await op1;
                  co_await op2;
                  
                  ...
                  co_return 0;
                }
              </script></code></pre>
            </div>
            <div class="codeTextItem">
              <img
                src="images/awaitable-combine.drawio.svg"
                alt="awaitable-combine"
              />
            </div>
          </div>
        </section>
        <!-- C++中Awaitable对象具有传递性，
        一个Op子对象对应一个Awaitable对象，多个Op可以在一个Task内部传递。
        可以通过Awaitable对象的传递性将一个或多个Op组合成一个Task。
        同样C++编译器也为这种传递性提供了支持。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>C++实现中Task执行流程</h4>
          <div class="codeText">
            <div class="codeTextItem">
              <img
                src="images/task-cpp.drawio.svg"
                alt="task-cpp"
                width="650"
              />
            </div>
          </div>
        </section>
        <!-- 最终C++实现中Task执行的时序图如下。 -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>其他模块：...</h4>
          <div class="codeText">
            <div class="codeTextItem">
              <img src="images/todo.drawio.svg" alt="todo" width="500" />
            </div>
          </div>
        </section>
        <!-- 由于时间关系，其他一些功能模块这里不再介绍，
        感兴趣的同学和老师可以参考毕业论文。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>
            <a href="https://github.com/sekirio-rs/Emma">Emma</a>（Rust）和<a
              href="https://github.com/sekirio-rs/Kuro"
              >Kuro</a
            >（C++）
          </h4>
          <div class="codeText">
            <div class="codeTextItem">
              <img src="images/emma.png" alt="emma" />
            </div>
            <div class="codeTextItem">
              <img src="images/kuro.png" alt="kuro" />
            </div>
          </div>
        </section>
        <!-- 最终成果是实现了两个异步编程框架Emma和Kuro。 -->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>性能测试</h4>
          <div class="codeText">
            <div class="codeTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  测试对象：Emma，Kuro和以下框架；
                </li>
                <ul>
                  <li style="margin-bottom: 5px">
                    Tokio：最成熟的Rust异步运行时；
                  </li>
                  <li style="margin-bottom: 5px">
                    async-std：Rust异步运行时新起之秀；
                  </li>
                  <li style="margin-bottom: 5px">Go：Go语言原生协程框架;</li>
                  <li style="margin-bottom: 5px">
                    Sync：同步I/O和多线程框架。
                  </li>
                </ul>
                <li style="margin-bottom: 5px">
                  测试方法：用各个框架实现一个HTTP服务器，然后使用Apache
                  Benchmark软件对服务器进行压力测试，并对比测试结果；
                </li>
                <li style="margin-bottom: 5px">测试指标：服务器吞吐量；</li>
                <li style="margin-bottom: 5px">测试环境：</li>
                <ul>
                  <li style="margin-bottom: 5px">
                    CPU：Intel(R) Xeon(R) Gold 5117 CPU @ 2.00GHz，56核；
                  </li>
                  <li style="margin-bottom: 5px">
                    内存：32GB，2666 MT/s x 16（条）；
                  </li>
                  <li style="margin-bottom: 5px">
                    网卡：Intel Corporation Ethernet Connection X722 for 10GbE
                    SFP+ (rev 09)。
                  </li>
                </ul>
              </ol>
            </div>
            <div class="codeTextItem">
              <img
                src="images/per-test.drawio.svg"
                alt="per-test"
                width="600"
              />
            </div>
          </div>
        </section>
        <!-- 接下来讲下性能测试。因为毕设实现的是异步编程框架，
        因此这里主要进行框架和框架之间的性能对比。
        测试对象是实现的框架Emma和Kuro
        和开源社区中三个比较主流和高性能的异步编程框架Tokio，async-std和Go。
        同时，为了验证异步I/O和协程的高性能，添加一组对照组，同步I/O和多线程框架，
        名叫Sync框架。
        测试方法是用各个框架分别编写一个HTTP服务器应用程序，然后用Apache Benchmark
        这个测试工具对实现的服务器进行压力测试，最终对比测试结果。
        测试指标是服务器的吞吐量。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>测试结果</h4>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  横坐标是HTTP请求数，纵坐标是服务器吞吐量；
                </li>
                <li style="margin-bottom: 5px">
                  随着请求数增大，服务器吞吐量趋于一个恒定值；
                </li>
                <li style="margin-bottom: 5px">
                  Emma和Kuro框架的吞吐量最高，Go框架的吞吐量最低；
                </li>
                <li style="margin-bottom: 5px">
                  Kuro框架比同步I/O和多线程框架在吞吐量指标上最高能达到78%的提升。
                </li>
              </ol>
            </div>
            <div class="image">
              <img
                src="images/test-result.png"
                alt="test-result"
                width="1000"
              />
            </div>
          </div>
        </section>
        <!-- 右边这两张图分别是在20和200个客户端并发请求条件下的测试结果。
        横坐标是HTTP请求数，纵坐标是服务器吞吐量。
        从图中可以看到，Emma和Kuro框架的整体吞吐量是最高的，Go框架的最低。
        这证明我们实现的两款框架都有比较好的性能。
        此外大部分异步编程框架的性能曲线都比同步I/O和多线程框架要高，
        其中Kuro框架最高可以比Sync框架高78%左右的性能，
        这证明了异步I/O和协程的高性能。-->

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <h4>总结与展望</h4>
          <div class="imageText">
            <div class="imageTextItem">
              <ol>
                <li style="margin-bottom: 5px">
                  基于Linux平台上的异步I/O技术（io_uring）和Rust/C++语言的协程技术设计并实现了两款
                  异步编程框架<mark>Emma和Kuro</mark>，在给上层应用开发带来便利的同时，验证了异步I/O和协程
                  的高效性；
                </li>
                <li style="margin-bottom: 5px">
                  后续计划可以从丰富功能和规范测试两个方面入手：
                </li>
                <ul>
                  <li style="margin-bottom: 5px">
                    为Emma和Kuro框架适配io_uring的高级用法，实现更多功能；
                  </li>
                  <li style="margin-bottom: 5px">
                    搭建更加规范，完善的测试环境，得出更准确，更全面的测试结果。
                  </li>
                </ul>
                <!-- <li style="margin-bottom: 5px"> -->
                <!--   感谢我的校内导师-华中科技大学的邵志远老师和校外导师-清华大学的陈渝老师。 -->
                <!-- </li> -->
              </ol>
            </div>
          </div>
        </section>

        <section
          data-background-image="images/background.jpg"
          data-background-opacity="0.25"
        >
          <div class="codeText">
            <div class="codeTextItem">
              <h3>毕设成果为本PPT的演示提供支持！</h3>
            </div>
            <div class="codeTextItem">
              <pre><code data-line-numbers data-trim data-noescape><script type="text/template">
                 <!-- 前端 -->
                <img src="http://172.26.222.85:3344/github.svg">

                // 后端
                async fn main() {
                  // 监听ip地址和端口
                  let listener = TcpListener::bind("0.0.0.0:3344").await;
                  
                  loop {
                    // 建立TCP连接
                    let stream = listener.accept().await;

                    Runtime::spawn(async move {
                      let mut buf = [0; BUF_LEN];
                      
                      // 接收HTTP请求
                      stream.recv(&mut buf).await;
                      
                      // 处理HTTP请求
                      handle_request(&mut buf);
                      
                      // 发送响应字节流
                      stream.send(&buf).await;
                    });
                  }
                }
              </script></code></pre>
            </div>
          </div>
        </section>
        <!-- 本PPT演示依赖于我的毕设成果提供的支持。
        这个PPT是一个前端项目，其中某些图片资源是请求后端返回的，
        而后端服务是基于毕设项目Emma搭建的。-->

        <section data-background-image="images/background.jpg" data-background-opacity=0.25>
          <div class="imageText">
            <div class="imageTextItem">
              <h2>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp感谢观看！</h2>
            </div>
            <div class="imageTextItem">
              <img src="images/chuangzhen.png" height="500" width="500">
            </div>
          </div>
        </section>

        <!-- <section -->
        <!--   data-background-image="images/background2.jpeg" -->
        <!--   data-background-opacity="0.25" -->
        <!-- > -->
        <!--   <h2>感谢观看！</h2> -->
        <!-- </section> -->
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
